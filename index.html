<div id="chart"></div>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-scale.v2.min.js"></script>
<!-- <script src="https://d3js.org/d3-dsv.v1.min.js"></script> -->
<script src="https://d3js.org/d3-fetch.v1.min.js"></script>
<style>
  @import url("/style.css");
  @import url("/syntax.css");
  @import url("/d3-building.css");
</style>
<script src="/data.js"></script>
<script>
  var w = 960,
      h = 500,
      x = d3.scaleLinear().range([0, 0.8 * w]).domain([0, surfaceMax]),
      y = d3.scaleLinear().range([0, 0.8 * h]).domain([0, levelCount + 1]);

  // An SVG element with a bottom-right origin.
  var svg = d3.select('#chart').append('svg:svg')
      .attr('width', w)
      .attr('height', h)
    .append('svg:g');

  // A sliding container to hold the bars.
  var body = svg.append('svg:g')
    .attr('transform', 'translate(' + .1 * w + ',' + .1 * h + ')');

  const GROUND = {};

  // Add labeled rects for each level.
  var levels = body.selectAll('g')
      .data(data)
    .enter().append('svg:g')
      .attr('transform', function(d, i) {
        if (d.name === 'SS1') {
          GROUND.y = i;
          GROUND.x = (surfaceMax - d.surface) / 2;
          GROUND.width = d.surface;
        }
        return 'translate(' + x((surfaceMax - d.surface) / 2) + ',' + y(i) + ')';
      });

  levels.selectAll('rect')
    .data(d => d.rooms.map(v => Object.assign(v, {parent: d})))
  .enter().append('svg:rect')
      .attr('x', (d, i) => {
        var offset = 0;
        for (var h = 0; h < i; ++h) {
          offset += d.parent.rooms[h].surface;
        }
        return x(offset);
      })
      .attr('width', d => x(d.surface))
      .attr('height', y(1))
      .attr('class', d => d.typo);
      // .attr('data-rvt-id', Math.random());

  // ground hatches

  // A hatchPattern filling rects
  // from https://stackoverflow.com/questions/13069446/simple-fill-pattern-in-svg-diagonal-hatching
  var hatchPattern = svg.append('svg:pattern')
      .attr('id', 'diagonalHatch')
      .attr('patternUnits', 'userSpaceOnUse')
      .attr('width', 8)
      .attr('height', 8)
    .append('path')
      .attr('d', 'M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2')
      .style('stroke', 'black')
      .style('stroke-width', '1');

  var offset = .025 * w;
  var paths = svg.append('svg:g')
      .attr('transform', 'translate(' + (.1 * w - offset) + ',' + .1 * h + ')');

  // ground hatch
  paths.append('svg:path')
      .attr('d', `M ${x(0)} ${y(GROUND.y)}
            H ${x(GROUND.x) + offset}
            V ${y(GROUND.y + 1)}
            H ${x(GROUND.width + GROUND.x) + offset}
            V ${y(GROUND.y)}
            H ${x(surfaceMax) + 2 * offset}
            V ${y(GROUND.y) + .5 * offset}
            H ${x(GROUND.width + GROUND.x) + 1.5 * offset}
            V ${y(GROUND.y + 1) + .5 * offset}
            H ${x(GROUND.x) + .5 * offset}
            V ${y(GROUND.y) + .5 * offset}
            H ${x(0)}
            Z`)
      .classed('ground-hatch', true);

  // underground hatch
  // paths.append('svg:path')
  //     .attr('d', `M ${x(0)} ${y(GROUND.y) + .5 * offset}
  //           H ${x(GROUND.x) + .5 * offset}
  //           V ${y(GROUND.y + 1) + .5 * offset}
  //           H ${x(GROUND.width + GROUND.x) + 1.5 * offset}
  //           V ${y(GROUND.y) + .5 * offset}
  //           H ${x(surfaceMax) + 2 * offset}
  //           V ${y(GROUND.y + 2)}
  //           H ${x(0)}
  //           Z`)
  //     .classed('underground-hatch', true);

  // ground cut
  paths.append('svg:path')
      .attr('d', `M ${x(0)} ${y(GROUND.y)}
                  H ${x(GROUND.x) + offset}
                  V ${y(GROUND.y + 1)}
                  H ${x(GROUND.width + GROUND.x) + offset}
                  V ${y(GROUND.y)}
                  H ${x(surfaceMax) + 2 * offset}`)
      .classed('ground-cut', true);

  // A container to hold the y-axis rules.
  var rules = svg.append('svg:g')
    .attr('transform', 'translate(' + 0 + ',' + .1 * h + ')');

  // Add rules for each level.
  rules = rules.selectAll('.rule')
    .data(data)
  .enter().append('svg:g')
    .attr('class', 'rule')
    .attr('transform', function(d, i) { return 'translate(0,' + y(i + 1) + ')'; });

  rules.append('svg:line')
      .attr('x1', .05 * w)
      .attr('x2', .95 * w);

  rules.append('svg:text')
      .attr('transform', 'translate(0,' + -y(0.5) + ')')
      .attr('x', 0.96 * w)
      .attr('dy', '.35em')
      .text(d => d.name);

  const TEXT_BORDER_OFFSET = 2;

  rules.append('svg:rect')
      .attr('transform', 'translate(0,' + -y(0.5) + ')')
      .attr('x', function(d) { return this.previousElementSibling.getBBox().x - TEXT_BORDER_OFFSET;})
      .attr('y', function(d) { return this.previousElementSibling.getBBox().y - TEXT_BORDER_OFFSET;})
      .attr('width', function(d) { return this.previousElementSibling.getBBox().width + 2 * TEXT_BORDER_OFFSET;})
      .attr('height', function(d) { return this.previousElementSibling.getBBox().height + 2 * TEXT_BORDER_OFFSET;});

  document.querySelectorAll('rect').forEach(node => {
    node.addEventListener('click', function() {
      console.log(this.dataset['rvtId']);
    });
  });

</script>