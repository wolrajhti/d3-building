<div id="chart"></div>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-scale.v2.min.js"></script>
<!-- <script src="https://d3js.org/d3-dsv.v1.min.js"></script> -->
<script src="https://d3js.org/d3-fetch.v1.min.js"></script>
<style>
  @import url("/style.css");
  @import url("/syntax.css");
  @import url("/d3-building.css");
</style>
<script src="/data.js"></script>
<script>
  const w = 960;
  const h = 500;
  const x = d3.scaleLinear().range([0, 0.8 * w]).domain([0, surfaceMax]);
  const y = d3.scaleLinear().range([0, 0.8 * h]).domain([0, levelCount + 1]);

  const buildingOffsetX = .1 * w;
  const buildingOffsetY = .1 * h;
  const infraY = data.findIndex(d => d.name === 'RdC') + 1;
  const infraWidth = data.filter((d, i) => i >= infraY)
    .reduce((surfaceMaxInfra, level) => Math.max(surfaceMaxInfra, level.surface), 0);

  const infraX = (surfaceMax - infraWidth) / 2;
  const infraHeight = data.length - infraY;

  // An SVG element with a bottom-right origin.
  var svg = d3.select('#chart')
    .append('svg:svg')
      .attr('width', w)
      .attr('height', h);

  // A sliding container to hold the bars.
  var building = svg.append('svg:g')
    .attr('transform', 'translate(' + buildingOffsetX + ',' + buildingOffsetY + ')')
    .attr('id', 'building');

  var title = svg.append('svg:text')
    .attr('x', buildingOffsetX + x(surfaceMax) / 2)
    .attr('y', y(1) / 2)
    .classed('project-name', true)
    .text(projectName);

  // Add labeled rects for each level.
  var levels = building.selectAll('g')
      .data(data)
    .enter().append('svg:g')
      .attr('transform', (d, i) => 'translate(' + x((surfaceMax - d.surface) / 2) + ',' + y(i) + ')');

  var rooms = levels.selectAll('g')
    .data(d => d.rooms.map(v => Object.assign(v, {parent: d})))
  .enter().append('svg:g')
      .attr('transform', (d, i) => {
        var offset = 0;
        for (var h = 0; h < i; ++h) {
          offset += d.parent.rooms[h].surface;
        }
        return 'translate(' + x(offset) + ',0)';
      });

  rooms.append('svg:rect')
      .attr('width', d => x(d.surface))
      .attr('height', y(1))
      .attr('class', d => d.typo)
      .classed('room', true)
      .attr('data-rvt-id', Math.random());

  var roomLabels = rooms.append('svg:g')
      .attr('transform', d => 'translate(' + (x(d.surface) / 2) + ',' + (y(1) / 2) + ')');
  
  roomLabels.append('svg:text')
      .attr('dy', '-.5em')
      .text(d => d.typo)
      .style('display', function(d) {
        if (this.getComputedTextLength() + 5 > x(d.surface)) {
          return 'none';
        }
      })
      .classed('room-label', true);

  roomLabels.append('svg:text')
      .attr('dy', '1em')
      .html(d => d.surface + ' m<tspan baseline-shift="super">2</tspan>')
      .style('display', function(d) {
        if (this.getComputedTextLength() + 5 > x(d.surface)) {
          return 'none';
        }
      })
      .classed('room-surface', true);

  // ground hatches

  // A hatchPattern filling rects
  // from https://stackoverflow.com/questions/13069446/simple-fill-pattern-in-svg-diagonal-hatching
  var hatchPattern = svg.append('svg:pattern')
      .attr('id', 'diagonalHatch')
      .attr('patternUnits', 'userSpaceOnUse')
      .attr('width', 8)
      .attr('height', 8)
    .append('path')
      .attr('d', 'M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2')
      .style('stroke', 'black')
      .style('stroke-width', '1');

  var groundOffset = .025 * w;
  var paths = svg.append('svg:g')
      .attr('transform', 'translate(' + (buildingOffsetX - groundOffset) + ',' + buildingOffsetY + ')');

  // ground hatch
  paths.append('svg:path')
      .attr('d', `M ${x(0)} ${y(infraY)}
            H ${x(infraX) + groundOffset}
            V ${y(infraY + infraHeight)}
            H ${x(infraWidth + infraX) + groundOffset}
            V ${y(infraY)}
            H ${x(surfaceMax) + 2 * groundOffset}
            V ${y(infraY) + .5 * groundOffset}
            H ${x(infraWidth + infraX) + 1.5 * groundOffset}
            V ${y(infraY + infraHeight) + .5 * groundOffset}
            H ${x(infraX) + .5 * groundOffset}
            V ${y(infraY) + .5 * groundOffset}
            H ${x(0)}
            Z`)
      .classed('ground-hatch', true);

  // underground hatch
  // paths.append('svg:path')
  //     .attr('d', `M ${x(0)} ${y(infraY) + .5 * groundOffset}
  //           H ${x(infraX) + .5 * groundOffset}
  //           V ${y(infraY + infraHeight) + .5 * groundOffset}
  //           H ${x(infraWidth + infraX) + 1.5 * groundOffset}
  //           V ${y(infraY) + .5 * groundOffset}
  //           H ${x(surfaceMax) + 2 * groundOffset}
  //           V ${y(infraY + infraHeight + 1)}
  //           H ${x(0)}
  //           Z`)
  //     .classed('underground-hatch', true);

  // ground cut
  paths.append('svg:path')
      .attr('d', `M ${x(0)} ${y(infraY)}
                  H ${x(infraX) + groundOffset}
                  V ${y(infraY + infraHeight)}
                  H ${x(infraWidth + infraX) + groundOffset}
                  V ${y(infraY)}
                  H ${x(surfaceMax) + 2 * groundOffset}`)
      .classed('ground-cut', true);

  // A container to hold the y-axis rules.
  var rules = svg.append('svg:g')
    .attr('transform', 'translate(0,' + .1 * h + ')');

  // Add rules for each level.
  rules = rules.selectAll('g')
    .data(data)
  .enter().append('svg:g')
    .attr('transform', function(d, i) { return 'translate(0,' + y(i + 1) + ')'; });

  rules.append('svg:line')
      .attr('x1', .05 * w)
      .attr('x2', .95 * w)
      .classed('level-line', true);

  rules.append('svg:text')
      .attr('transform', 'translate(0,' + -y(0.5) + ')')
      .attr('x', 0.96 * w)
      .attr('dy', '.35em')
      .text(d => d.name)
      .classed('level-label', true);

  const TEXT_BORDER_OFFSET = 2;

  rules.append('svg:rect')
      .attr('transform', 'translate(0,' + -y(0.5) + ')')
      .attr('x', function(d) { return this.previousElementSibling.getBBox().x - TEXT_BORDER_OFFSET;})
      .attr('y', function(d) { return this.previousElementSibling.getBBox().y - TEXT_BORDER_OFFSET;})
      .attr('width', function(d) { return this.previousElementSibling.getBBox().width + 2 * TEXT_BORDER_OFFSET;})
      .attr('height', function(d) { return this.previousElementSibling.getBBox().height + 2 * TEXT_BORDER_OFFSET;})
      .classed('level-label-box', true);

  document.querySelectorAll('rect').forEach(node => {
    node.addEventListener('click', function() {
      console.log(this.dataset['rvtId']);
    });
  });

</script>